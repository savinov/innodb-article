### Блокировки
В InnoDB блокировки происходят на уровне строк, что позволяет различным транзакциям работать с одними и теми же таблицами одновременно. В случае когда транзакция пытается изменить строку, в которую уже вносит изменение другая транзакция, происходит блокировка, т.е. ожидание пока первая транзакция не закончит работу с изменяемой строкой. Любой вид блокировки строк - это по сути блокировка индексов. В случае если в таблице не объявленны уникальные индексы, InnoDB создаст скрытый ключ в виде номера строки (подробнее см. [Clustered and Secondary Indexes](http://dev.mysql.com/doc/refman/5.7/en/innodb-table-and-index.html#innodb-index-types)) и будет вешать блокировки на них. Посмотреть какие индексы есть в таблице можно с помощью команды `SHOW INDEX FROM <table name>`.

Существует три типа блокировок:

1. блокировка индексной записи ([record lock](http://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_record_lock)) - такая блокировка происходит, если условие запроса ограничивает только одну запись уникального индекса ([unique index](http://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_unique_index)); например, если в таблице `t` поле `c1` является уникальным индексом и существует запись для которой `с1 = 10`, то при выполнении блокирующего чтения `SELECT * FROM t WHERE c1 = 10 FOR UPDATE` InnoDB установит блокировку на этот индекс и не допустит чтобы другая транзакция вставила, обновила или удалила строку с полем `с1 = 10`; если выполнить тот же запрос, но записи с полем `с1 = 10` (а соответственно и записи индекса) не будет существовать, то это уже будет блокировка интервала
2. блокировка интервала ([gap lock](http://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_gap_lock)) - происходит когда блокируется интервал между индексными записями, интервал до первой индексной записи или интервал после последней индексной записи; допустим что в таблице есть две строки для которых `с1 = 10` и `c1 = 20`, т.е. индекс содержит значения 10 и 20; интервалами будут являтся следующие отрезки: (минус бесконечность, 10), (10,  20), (20, плюс беконечность); если мы выполним запрос на блокирующее чтение несуществующей пока записи `SELECT * FROM t WHERE c1 = 15 FOR UPDATE`, то будет блокирован интервал от 10 до 20, но не включительно, т.е. обновить граничные записи можно, можно даже их удалить, а вот вставка новой строки в этот интервал будет блокирована; еще один интересный пример: если выполнить предыдущий запрос на блокирующее чтение строки, но таблица `t` будет пуста, то заблокируется интервал, размером во все индексное пространство, т.е. вся таблица
3. блокировка следующего ключа ([next-ket lock](http://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_next_key_lock)) - комбинация блокировок индексных записей и блокировок интервалов; возьмем предыдущий пример, но выполним другой запрос: `SELECT * FROM t WHERE t > 15`; в данном случае помимо индекса со значением 20 заблокируются также интервалы (10, 20) и (20, плюс бесконечность); при этом строку с индексом 10 можно изменять, т.к. она не блокируется; в общем случае блокируемых индексных интервалов и индексных записей может быть гораздо больше, все зависит от условий блокирующего запроса
 
Таким образом видно, что InnoDB использует блокироки интервалов и блокировки следующего ключа так, чтобы полностью покрыть условие поиска блокирующего запроса и при этом заблокировать наименьшее возможное количество индексного пространства. Рассмотрим как блокировки интервалов и блокировки следующих ключей решают проблему фантомных чтений ([Phantom Problem](http://dev.mysql.com/doc/refman/5.7/en/innodb-next-key-locking.html)). Фантомное чтение - это когда в рамках одной транзакции возвращается разные результаты. Возьмем последний пример и допустим что для текущей транзакции установлен уровень изоляции READ UNCOMMITTED или READ COMMITED. Выполним блокирующее чтение `SELECT * FROM t WHERE c1 BETWEEN 12 AND 18` и получим пустое множество. Теперь в другой транзакции (с любым уровнем изоляции) выполним запрос на вставку строки: `INSERT INTO t (c1) VALUES (15)`. В первой транзакции повторим то же самое блокирующее чтение и в результате получим фантомную строку с полем `c1 = 15`, вставленную второй транзакцией. Если попробовать провернуть все то же самое но установив для первой транзакции уровень изоляции REPEATABLE READ или SERIALIZABLE, то при попытке вставки строки второй транзакцией она будет блокирована, т.к. первая транзакция заблокирует индексный интервал (10, 20). Таким образом блокирующее чтение будет возвращать один и тот же результат (пустое множество), независимо от действий других транзакций. Блокировка следующего ключа избавляет от фантомных чтений аналогично, с той лишь разницей что в этих блокировках могут участвовать несколько индексных записей и интервалов.

