В MySQL, начиная с версии 5.5 по-умолчанию используется движок таблиц [InnoDB](http://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html). В данной статье речь пойдет том каким образом этот движок поддерживает транзакции, какие используются типы блокировок, как работает механизм многоверсионности, также поговорим о том как возникают deadlocks и что с ними делать.

InnoDB следует принципам [ACID](http://dev.mysql.com/doc/refman/5.7/en/mysql-acid.html) (Atomicity, Consistency, Isolation, Durability). В рамках обсуждаемой темы нас интересуют два принципа: атомарность и изоляция, которые обеспечиваются в основном за счет транзакций и блокировок.
### Транзакции
Для обеспечения атомарности любая последовательность операций выполняется в рамках своей транзакции, т.е. все изменения выполняемые транзакцией либо применяются - `COMMIT`, либо откатываются - `ROLLBACK`. По-умолчанию каждая новая сессия работает в режиме автоматического коммита. В этом режиме любое SQL-выражение либо будет автоматически закоммичено (при отсутсвии ошибок), либо будет откатано назад (при возникновении ошибки поведение коммита и роллбека зависит от типа ошибки, см. [Error Handling](http://dev.mysql.com/doc/refman/5.7/en/innodb-error-handling.html)). Чтобы выполнять последовательность операций без автокоммита, можно либо воспользоваться выражениями `START TRANSACTION` / `BEGIN`, либо выключить автокоммит с помощью выражения `SET autocommit = 0`. При выключенном автокоммите транзакция будет открыта до тех пор пока явно не выполнится `COMMIT` или `ROLLBACK`, которые завершат текущую тразакцию и начнут новую. При выполнении `COMMIT` или `ROLLBACK` все блокировки установленные внутри транзакции снимаются.

Изоляция транзакций в InnoDB реализована в соответсвии со стандартом [SQL-92](http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt) в виде четырех уровней: *READ UNCOMMITTED*, *READ COMMITTED*, *REPEATABLE READ*, *SERIALIZABLE*. По-умолчанию используется *REPEATABLE READ*. Пользователь может изменить уровень изоляции для текущей сессии или для всех новых сессий с помощью выражения [`SET TRANSACTION`](http://dev.mysql.com/doc/refman/5.7/en/set-transaction.html). Перед тем как рассмотреть что из себя представляют эти уровни изоляции, стоит кратко пояснить что чтение бывает двух типов: консистентное неблокирующее ([Consistent Nonlocking Reads](http://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html) - обычные `SELECT`) и блокирущее ([Locking Reads](http://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html) - `SELECT ... FOR UPDATE` и `SELECT ... LOCK IN SHARE MODE`). О типах чтения и блокировках поговорим подробнее чуть позже. Итак, рассмотрим что же из себя представляют уровни изоляции транзакций:

1. READ UNCOMMITTED. Самый низкий уровень изоляции. При этом уровне изоляции для неблокирующих чтений возможны ситуации когда будут использованы ранние версии данных. Такие чтения будут неконсистентны, их еще называют "грязным чтением". В остальном этот уровень работает так же как READ COMMITED.
2. READ COMMITED. При этом уровне изоляции каждое неблокирующее чтение работает со своим собственным свежим снимком, в том числе и в рамках одной транзакции. При выполнении блокирующих чтений, UPDATE и DELETE будут блокироваться только индексные записи ([record lock](http://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_record_lock)) и не будут блокираться интервалы ([gaps](http://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_gap)). Поэтому данный уровень изоляции позволяет вставлять новые строки в интервалы перед индексными записями. Такие строки называют фантомными. Уровень REPEATABLE READ решает данную проблему.
3. REPEATABLE READ. При этом уровне изоляции каждое неблокирующие чтение (так же как и при READ COMMITED) работает со своим снимком, но снимок этот не обновляется в рамках одной транзакции, а используется тот что был получен при первом чтении. Т.е. каждое неблокирующее чтение в рамках одной транзакции является консистентным по отношению к остальным. Поведение блокирующего чтения, UPDATE и DELETE зависит от уникальности индекса и уникальности условия поиска. Когда и индекс и условие поиска уникально - блокируется только найденная индексная запись и не блокируется интервал перед ней. В остальных случаях InnoDB будет блокировать некоторый индексный интервал, используя так называемую интервальную блокировку [gap lock](http://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_gap_lock) или блокировку следующего ключа [next-key lock](http://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_next_key_lock). Блокировка следующего ключа позволяет избежать фантомных записей ([Phantom Problem](http://dev.mysql.com/doc/refman/5.7/en/innodb-next-key-locking.html)).
4. SERIALIZABLE. Этот уровень аналогичен REPEATABLE READ, но InnoDB будет неявно преобразовывать все неблокирующие чтения (`SELECT`), в блокирующие (`SELECT ... LOCK IN SHARE MODE`) если автокоммит выключен. В случае если автокоммит включен, неблокирующее чтение будет единственным оператором в транзакции, т.е. понятно что транзакция будет read only, соответственно не имеет смысла блокировать записи такой транзакцией.

### Блокировки
В InnoDB блокировки происходят на уровне строк, что позволяет различным транзакциям работать с одними и теми же таблицами одновременно. В случае когда транзакция пытается изменить строку, в которую уже вносит изменение другая транзакция, происходит блокировка, т.е. ожидание пока первая транзакция не закончит работу с изменяемой строкой. Любой вид блокировки строк - это по сути блокировка индексов. В случае если в таблице не объявленны уникальные индексы, InnoDB создаст скрытый ключ в виде номера строки (подробнее см. [Clustered and Secondary Indexes](http://dev.mysql.com/doc/refman/5.7/en/innodb-table-and-index.html#innodb-index-types)) и будет вешать блокировки на них. Посмотреть какие индексы есть в таблице можно с помощью команды `SHOW INDEX FROM <table name>`.

Существует три типа блокировок:

1. блокировка индексной записи ([record lock](http://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_record_lock)) - такая блокировка происходит, если условие запроса ограничивает только одну запись уникального индекса ([unique index](http://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_unique_index)); например, если в таблице `t` поле `c1` является уникальным индексом и существует запись для которой `с1 = 10`, то при выполнении блокирующего чтения `SELECT c1 FOR UPDATE FROM t WHERE c1 = 10;` InnoDB установит блокировку на этот индекс и не допустит чтобы другая транзакция вставила, обновила или удалила строку с полем `с1 = 10`; если выполнить тот же запрос, но записи с полем `с1 = 10` (а соответственно и записи индекса) не будет существовать, то это уже будет блокировка интервала
2. блокировка интервала ([gap lock](http://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_gap_lock)) - происходит когда блокируется интервал между индексными записями, интервал до первой индексной записи или интервал после последней индексной записи; Допустим индекс содержит значения 10 и 20. Интервалами будут являтся следующие отрезки: (минус бесконечность, 10), (10,  20), (20, плюс беконечность); допустим что существует две строки для которых `с1 = 10` и `c1 = 20`, т.е. индекс содержит значения 10 и 20; если мы выполним запрос на блокирующее чтение несуществующей пока записи `SELECT c1 FOR UPDATE FROM t WHERE c1 = 15` будет блокирован интервал от 10 до 20, но не включительно, т.е. обновить граничные записи можно, можно даже их удалить, а вот вставка новой строки в этот интервал будет блокирована; еще один интересный пример: если выполнить предыдущий запрос на блокирующее чтение строки, но таблица `t` будет пуста - заблокируется интервал, размером во все индексное пространство, т.е. вся таблица
3. блокировка следующего ключа ([next-ket lock](http://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_next_key_lock)) - комбинация блокировки индексной записи и блокировки интервала перед ней; как уже говорилось выше, данный вид блокировок происходит при уровне изоляции транзакций REPEATABLE READ и избавляет от проблемы фантомных записей ([Phantom Problem](http://dev.mysql.com/doc/refman/5.7/en/innodb-next-key-locking.html));
