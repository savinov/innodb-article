В MySQL, начиная с версии 5.5 по-умолчанию используется движок таблиц [InnoDB](http://dev.mysql.com/doc/refman/5.6/en/innodb-storage-engine.html). В данной статье речь пойдет том каким образом этот движок поддерживает транзакции, какие используются виды блокировок, как работает механизм многоверсионности, о том как возникают deadlocks и что с ними делать.

InnoDB следует принципам [ACID](http://dev.mysql.com/doc/refman/5.6/en/mysql-acid.html) (Atomicity, Consistency, Isolation, Durability). В рамках обсуждаемой темы нас интересует два принципа: атомарность и изоляция.

Для обеспечения атомарности любая последовательность операций выполняется в рамках своей транзакции, т.е. все изменения выполняемые транзакцией либо применяются - `COMMIT`, либо откатываются - `ROLLBACK`. По-умолчанию каждая новая сессия работает в режиме автоматического коммита, т.е. любое SQL-выражение либо будет автоматически закоммичено (при отсутсвии ошибок), либо будет автоматичемки откатано назад (при возникновении определенных ошибок, см. [Error Handling](http://dev.mysql.com/doc/refman/5.6/en/innodb-error-handling.html)). Чтобы выполнять последовательность операций без автокоммита, можно либо воспользоваться выражениями `START TRANSACTION` / `BEGIN`, либо выключить автокоммит с помощью выражения `SET autocommit = 0`. При выключенном автокоммите транзакция будет открыта до тех пор пока не выполнится `COMMIT` или `ROLLBACK`, которые завершат текущую тразакцию и начнут новую. При выполнении `COMMIT` или `ROLLBACK` все блокировки установленные транзакцией снимаются.

Изоляция транзакций в InnoDB реализована в соответсвии со стандартом [SQL-92](http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt) в виде четырех уровней: *READ UNCOMMITTED*, *READ COMMITTED*, *REPEATABLE READ*, *SERIALIZABLE*. По-умолчанию используется *REPEATABLE READ*. Пользователь может изменить уровень изоляции для текущей сессии или для всех новых сессий с помощью выражения [`SET TRANSACTION`](http://dev.mysql.com/doc/refman/5.6/en/set-transaction.html). Перед тем как рассмотреть что из себя представляют эти уровни изоляции, стоит отметить что чтение бывает двух типов: неблокирующее ([Nonlocking Reads](http://dev.mysql.com/doc/refman/5.6/en/innodb-consistent-read.html), обычные `SELECT`) и блокирущее ([Locking Reads](http://dev.mysql.com/doc/refman/5.6/en/innodb-locking-reads.html), `SELECT ... FOR UPDATE` и `SELECT ... LOCK IN SHARE MODE`). О них поговорим подробнее чуть позже. Итак, рассмотрим что же из себя представляют уровни изоляции транзакций:

1. READ UNCOMMITTED. Самый низкий уровень изоляции. При этом уровне изоляции для неблокирующих чтений возможны ситуации когда будут использованы ранние версии данных. Такие чтения будут неконсистентны, их еще называют "грязным чтением". В остальном этот уровень работает так-же как READ COMMITED.  
2. READ COMMITED. При этом уровне изоляции каждое неблокирующее чтение работает со своим собственным свежим снимком, в том числе и в рамках одной транзакции. При выполнении блокирующих чтений, UPDATE и DELETE будут блокироваться только индексные записи ((record lock)[http://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_record_lock]) и не будет блокираться интервалы ([gaps](http://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_gap), о них поговорим отдельно). Поэтому данный уровень изоляции позволяет встявлять новые строки в интервалы. Такие строки называют фантомными, об этой проблеме поговорим чуть позже.  
3. REPEATABLE READ. При этом уровне изоляции каждое неблокирующие чтение (так же как и при READ COMMITED) работает со своим снимком, но снимок этот не обновляется в рамках одной транзакции, а используется тот что был получен при первом чтении. Т.е. каждое неблокирующее чтение в рамках одной транзакции является консистентным по отношению к остальным. Поведение блокирующего чтения, UPDATE и DELETE зависит от уникальности индекса и уникальности условия поиска. Когда и индекс и условие поиска уникально - блокируется только найденная индексная запись и не блокируется интервал перед ней. В остальных случаях InnoDB будет блокировать некоторый индексный интервал, используя так называемую интервальную блокировку (gap lock)[http://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_gap_lock] или блокировку следующего ключа (next-key lock)[http://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_next_key_lock]. Блокировка следующего ключа позволяет избежать фантомных записей.
4. 
