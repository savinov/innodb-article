В MySQL, начиная с версии 5.5 по-умолчанию используется движок таблиц [InnoDB](http://dev.mysql.com/doc/refman/5.6/en/innodb-storage-engine.html). В данной статье речь пойдет том каким образом этот движок поддерживает транзакции, какие используются виды блокировок, как работает механизм многоверсионности, также поговорим о том как возникают deadlocks и что с ними делать.

InnoDB следует принципам [ACID](http://dev.mysql.com/doc/refman/5.6/en/mysql-acid.html) (Atomicity, Consistency, Isolation, Durability). В рамках обсуждаемой темы нас интересуют два принципа: атомарность и изоляция.
### Транзакции
Для обеспечения атомарности любая последовательность операций выполняется в рамках своей транзакции, т.е. все изменения выполняемые транзакцией либо применяются - `COMMIT`, либо откатываются - `ROLLBACK`. По-умолчанию каждая новая сессия работает в режиме автоматического коммита. В этом режиме любое SQL-выражение либо будет автоматически закоммичено (при отсутсвии ошибок), либо будет откатано назад (при возникновении ошибки поведение коммита и роллбека зависит от типа ошибки, см. [Error Handling](http://dev.mysql.com/doc/refman/5.6/en/innodb-error-handling.html)). Чтобы выполнять последовательность операций без автокоммита, можно либо воспользоваться выражениями `START TRANSACTION` / `BEGIN`, либо выключить автокоммит с помощью выражения `SET autocommit = 0`. При выключенном автокоммите транзакция будет открыта до тех пор пока явно не выполнится `COMMIT` или `ROLLBACK`, которые завершат текущую тразакцию и начнут новую. При выполнении `COMMIT` или `ROLLBACK` все блокировки установленные транзакцией снимаются.

Изоляция транзакций в InnoDB реализована в соответсвии со стандартом [SQL-92](http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt) в виде четырех уровней: *READ UNCOMMITTED*, *READ COMMITTED*, *REPEATABLE READ*, *SERIALIZABLE*. По-умолчанию используется *REPEATABLE READ*. Пользователь может изменить уровень изоляции для текущей сессии или для всех новых сессий с помощью выражения [`SET TRANSACTION`](http://dev.mysql.com/doc/refman/5.6/en/set-transaction.html). Перед тем как рассмотреть что из себя представляют эти уровни изоляции, стоит кратко рассмотреть виды чтения и варианты блокировок на уровне строк.

Чтение бывает двух типов: консистентное неблокирующее ([Consistent Nonlocking Reads](http://dev.mysql.com/doc/refman/5.6/en/innodb-consistent-read.html) - обычные `SELECT`) и блокирущее ([Locking Reads](http://dev.mysql.com/doc/refman/5.6/en/innodb-locking-reads.html) - `SELECT ... FOR UPDATE` и `SELECT ... LOCK IN SHARE MODE`).

InnoDB в разных ситуациях применят один из трех вариантов блокировки на уровне строк:

1. record lock
2. gap lock
3. next-ket lock

О видах чтения и о вариантах блокировок на уровне строк поговорим подробнее чуть позже. Итак, рассмотрим что же из себя представляют уровни изоляции транзакций:

1. READ UNCOMMITTED. Самый низкий уровень изоляции. При этом уровне изоляции для неблокирующих чтений возможны ситуации когда будут использованы ранние версии данных. Такие чтения будут неконсистентны, их еще называют "грязным чтением". В остальном этот уровень работает так же как READ COMMITED.
2. READ COMMITED. При этом уровне изоляции каждое неблокирующее чтение работает со своим собственным свежим снимком, в том числе и в рамках одной транзакции. При выполнении блокирующих чтений, UPDATE и DELETE будут блокироваться только индексные записи ([record lock](http://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_record_lock)) и не будут блокираться интервалы ([gaps](http://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_gap)). Поэтому данный уровень изоляции позволяет встявлять новые строки в интервалы перед индексными записями. Такие строки называют фантомными. Уровень REPEATABLE READ решает данную проблему.
3. REPEATABLE READ. При этом уровне изоляции каждое неблокирующие чтение (так же как и при READ COMMITED) работает со своим снимком, но снимок этот не обновляется в рамках одной транзакции, а используется тот что был получен при первом чтении. Т.е. каждое неблокирующее чтение в рамках одной транзакции является консистентным по отношению к остальным. Поведение блокирующего чтения, UPDATE и DELETE зависит от уникальности индекса и уникальности условия поиска. Когда и индекс и условие поиска уникально - блокируется только найденная индексная запись и не блокируется интервал перед ней. В остальных случаях InnoDB будет блокировать некоторый индексный интервал, используя так называемую интервальную блокировку [gap lock](http://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_gap_lock) или блокировку следующего ключа [next-key lock](http://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_next_key_lock). Блокировка следующего ключа позволяет избежать фантомных записей.
4. SERIALIZABLE. Этот уровень аналогичен REPEATABLE READ, но InnoDB будет неявно преобразовывать все неблокирующие чтения (`SELECT`), в блокирующие (`SELECT ... LOCK IN SHARE MODE`) если автокоммит выключен. В случае если автокоммит включен, неблокирующее чтение будет единственным оператором в транзакции, т.е. понятно что транзакция будет read only, соответственно не имеет смысла блокировать записи такой транзакцией.
